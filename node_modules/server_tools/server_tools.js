//These functions are meant to help the server-side master (app.js)
var server_tools=new Object();
//This function takes a database object and a database query, and returns a JSON object which answers the query
server_tools.queryDatabase=function(database, query, socket)
{
	console.log(query.tag);
	if(query.msg=='')
	{
		if(query.tag=='station_list')
		{
			database.collection('stationlist').find().toArray(function(err,items)
			{
				if(err!=null) console.log(err);
				for(var i=0; i<items.length; i++)
				{
					items[i].birth_date=unixTimestampToJavascriptDate(items[i].birth_date);
				}
				var response={data:items, query:query};
				socket.emit('database_response_station_list', response);
				
			});
		}
		else if(query.tag=='error_prone_list')
		{
			database.collection('errorlist').find().sort({ground_station_id:1}).toArray(function(err,items)
			{
				database.collection('stationlist').find().sort({id:1}).toArray(function(err, stations)
				{
					if(err!=null) console.log(err);
					var temp=buildErrorProneList(items, stations);
					var response={data:temp, query:query};
					
					socket.emit('database_response_error_prone_list', response);
				});

			});
		}
		else if(query.tag=='recent_error_list')
		{

			database.collection('errorlist').find().sort({timestamp:-1}).toArray(function(err, items)
			{
				if(err!=null) console.log(err);

				for(var i=0; i<items.length; i++)
				{
					items[i].timestamp=unixTimestampToJavascriptDate(items[i].timestamp);
				}

				var response={data:items, query:query};
				socket.emit('database_response_recent_error_list', response);
			});
		}
		else if(query.tag=='module_failure_plot')
		{
			database.collection('errorlist').find().sort({module:1}).toArray(function(err, items)
			{
				console.log('module_error_plot');
				var temp=buildModuleFailureList(items, query.startDate, query.endDate);
				var response={data:temp, query:query};

				socket.emit('database_response_module_failure_plot', response);
			});

		}
		else if(query.tag=='swaps_before_failure_date')
		{
			database.collection('errorlist').find().sort({ground_station_id:1, timestamp:1}).toArray(function(err, items)
			{
				var temp=buildSwapsBeforeFailureDate(items);

				var response={data:temp, query:query};

				socket.emit('database_response_swaps_before_failure_data', response);
			});
		}
	}
	else if(query.tag=='swaps_before_failure_gs_average')
	{
		database.collection('errorlist').find().sort({ground_station_id:1}).toArray(function(err, items){
			var temp=buildSwapsBeforeFailureGSAverage(items);

			var response={data:temp, query:query};

			socket.emit('database_response_swaps_before_failure_gs_average', response);
		});
	}
	else if(query.tag=='swaps_before_failure_gs_best')
	{
		database.collection('errorlist').find().sort({ground_station_id:1}).toArray(function(err, items){
			var temp=buildSwapsBeforeFailureGSBest(items);

			var response={data:temp, query:query};

			socket.emit('database_response_swaps_before_failure_gs_best', response);
		});
	}
	else if(query.tag=='swaps_before_failure_gs_recent')
	{
		database.collection('errorlist').find().sort({ground_station_id:1, timestamp:-1}).toArray(function(err, items){
			var temp=buildSwapsBeforeFailureGSRecent(items);

			var response={data:temp, query:query};

			socket.emit('database_response_swaps_before_failure_gs_recent', response);
		});
	}
	else
	{
		database.collection(query.collection).find(query.msg).toArray(function(err,items)
		{
			if(err!=null) console.log(err);
			returnJSON=items;
		});
	}
	return;
}

function buildSwapsBeforeFailureDate(data)
{
	//the argument of this function should be an array of errors sorted by ground station and then by timestamp
	var returnArray=[]; //this is an array of objects which are each an array of date/swaps_before_fail pairs
	var stationArray=[];
	for(var i=0; i<data.length; i++)
	{
		data[i].timestamp+=i;
		data[i].timestamp=unixTimestampToJavascriptDate(data[i].timestamp);
		if(i==0)
		{
			stationArray.push(data[i]);
		}
		else if(data[i].ground_station_id!=data[i-1].ground_station_id)
		{
			//we are now talking about a new groundstation
			returnArray.push(stationArray);
			returnArray[returnArray.length-1].ground_station_id=data[i-1].ground_station_id;
			stationArray=[];
		}
		else
		{
			//add more entries to the same ground station
			stationArray.push(data[i]);
		}

	}
	return returnArray;
}

function buildSwapsBeforeFailureGSAverage(items)
{
	//creates a list of objects (prototypeObject) for use in the swap-before-failure-gs-average plot
	var returnArray=[]; 
	var prototypeObject={ground_station_id:0, total_swaps:0, total_samples:0, average_swaps_before_error:0};
	var push;
	for(var i=0; i<data.length; i++)
	{
		push=false;
		if(i==0)
		{
			prototypeObject.ground_station_id=data[i].ground_station_id;
			prototypeObject.total_swaps+=data[i].swaps_before_error;
			prototypeObject.total_samples+=1;
			if(data.length==1) push=true;
		}
		else if(data[i].ground_station_id!=data[i-1].ground_station_id)
		{
			//we are now talking about a new groundstation
			push=true;
		}
		else
		{
			//add more data to the same ground station
			prototypeObject.total_swaps+=data[i].swaps_before_error;
			prototypeObject.total_samples+=1;
			if(data.length-1==i) push=true;

		}
		if(push)
		{
			prototypeObject.average_swaps_before_error=prototypeObject.total_swaps/prototypeObject.total_samples;
			returnArray.push(prototypeObject);
			prototypeObject={ground_station_id:data[i].ground_station_id, total_swaps:data[i].swaps_before_error, total_samples:1, average_swaps_before_error:0};
		}

	}
	return returnArray;
}

function buildSwapsBeforeFailureGSBest(items)
{
	//creates a list of objects (prototypeObject) for use in the swap-before-failure-gs-average plot
	var returnArray=[]; 
	var prototypeObject={ground_station_id:0, best_swaps_before_error:0};
	var push;
	for(var i=0; i<data.length; i++)
	{
		push=false;
		if(i==0)
		{
			prototypeObject.ground_station_id=data[i].ground_station_id;
			prototypeObject.best_swaps_before_error=data[i].swaps_before_error;
			if(data.length==1) push=true;
		}
		else if(data[i].ground_station_id!=data[i-1].ground_station_id)
		{
			//we are now talking about a new groundstation
			push=true;
		}
		else
		{
			//add more data to the same ground station
			if(prototypeObject.best_swaps_before_error<=data[i].swaps_before_error) prototypeObject.best_swaps_before_error=data[i].swaps_before_error;
			if(data.length-1==i) push=true;
		}
		if(push)
		{
			returnArray.push(prototypeObject);
			prototypeObject={ground_station_id:data[i].ground_station_id, best_swaps_before_error:data[i].swaps_before_error};
		}
	}
	return returnArray;
}

function buildSwapsBeforeFailureGSRecent(items)
{
	//creates a list of objects (prototypeObject) for use in the swap-before-failure-gs-average plot
	var returnArray=[]; 
	var prototypeObject={ground_station_id:0, recent_swaps_before_error:0};
	var push;
	for(var i=0; i<data.length; i++)
	{
		push=false;
		if(i==0)
		{
			prototypeObject.ground_station_id=data[i].ground_station_id;
			prototypeObject.recent_swaps_before_error=data[i].swaps_before_error;
			push=true;
		}
		else if(data[i].ground_station_id!=data[i-1].ground_station_id)
		{
			//we are now talking about a new groundstation
			push=true;
		}
		if(push)
		{
			returnArray.push(prototypeObject);
			prototypeObject={ground_station_id:data[i].ground_station_id, best_swaps_before_error:data[i].swaps_before_error};
		}

	}
	return returnArray;
}



function buildErrorProneList(data, stationdata)
{
	//the input should be a set of documents from the errorlist database, which will be sorted by ground station id.
	//This function returns a JSON object which can be passed directly to jqGrid

	var returnArray=[];
	//Needs 4 properties: ground_station_id, lifetime_errors, last_error, and most_recent_error
	console.log("Building error prone list");

	console.log(data);
	for(var i=0; i<data.length; i++)
	{
		if(i==0)
		{
			returnArray.push({ground_station_id:data[i].ground_station_id, lifetime_errors:getStationById(data[i].ground_station_id, stationdata).lifetime_errors, last_error: data[i].timestamp, most_recent_error: data[i].timestamp});
		}
		else if(data[i].ground_station_id!=data[i-1].ground_station_id)
		{
			//we are now talking about a new groundstation
			returnArray.push({ground_station_id:data[i].ground_station_id, lifetime_errors:getStationById(data[i].ground_station_id, stationdata).lifetime_errors, last_error: data[i].timestamp, most_recent_error: data[i].timestamp});
		}
		else
		{
			returnArray[returnArray.length-1].lifetime_errors++;
			if(returnArray[returnArray.length-1].last_error<data[i].timestamp) returnArray[returnArray.length-1].last_error=data[i].timestamp;
			if(returnArray[returnArray.length-1].most_recent_error>data[i].timestamp) returnArray[returnArray.length-1].most_recent_error=data[i].timestamp;
		}
	}

	for(var i=0; i<returnArray.length; i++)
	{
		returnArray[i].last_error=unixTimestampToJavascriptDate(returnArray[i].last_error);
		returnArray[i].most_recent_error=unixTimestampToJavascriptDate(returnArray[i].most_recent_error);
	}

	return returnArray;
}

function buildModuleFailureList(data, startDate, endDate)
{
	//This will order the module failures by module.
	var returnArray=[];

	//This will exclude errors that do not fall in the range of dates specified by startDate and endDate
	var dataBuffer=[];

	startDate=convertDashDateToUnixTimestamp(startDate);
	endDate=convertDashDateToUnixTimestamp(endDate);
	for(var i=0; i<data.length; i++)
	{
		if(data[i].timestamp>startDate && data[i].timestamp<endDate)
		{ 
			dataBuffer.push(data[i]);
		}
	}
	for(var i=0; i<dataBuffer.length; i++)
	{
		if(i==0)
		{
			returnArray.push({module:dataBuffer[i].module, errors:1});
		}
		else if(dataBuffer[i].module==dataBuffer[i-1].module)
		{
			returnArray[returnArray.length-1].errors++;
		}
		else
		{
			returnArray.push({module:dataBuffer[i].module, errors:1});
		}
	}
	return returnArray;
}

function unixTimestampToJavascriptDate(timestamp)
{
	var tempDate=new Date(timestamp*1000);
    return (tempDate.toLocaleTimeString() + "  " + (tempDate.getMonth()+1) + "/" + tempDate.getDate() + "/" + tempDate.getFullYear());
}

function getStationById(id, stationlist)
{
	for(var i=0; i<stationlist.length; i++)
	{
		if(stationlist[i].id==id) return stationlist[i];
	}
	return null;
}

function convertDashDateToUnixTimestamp(dashdate)
{
	//the argument is a date string that looks like mm-dd-yyyy, e.x. 01-01-1970
	//this is used to convert datepicker dates into ones we can use in date comparisons
	var parts=dashdate.split("-");
	if(parts.length!=3) throw "Invalid Date Format";

	var myDate=new Date(dashdate);
	return myDate.getTime()/1000.0;
}

server_tools.parsePost=function(request, io)
{
	//*********************************
	//A groundstation POST looks like this:
	//{groundstation_name}:{groundstation_id}:{message}
	//The message looks like this:
	//{timestamp}:{level}:{event}:{details}
	//i.e. 12345678:notice:state_change:state1->state2
	//or   31415926:status:busy:swapping
	//or   27182818:error:timeout:mav_carousel

	//we really should have just passed an object, but oh well.

	var groundstation_id=request.groundstation_id;
	var groundstation_name=request.groundstation_name;
	var number_of_swaps=request.number_of_swaps;

	var messageBlocks=request.message.split(':');
	var timestamp=messageBlocks[0];
	var level=messageBlocks[1];
	var _event=messageBlocks[2]; //the damn "event" is a keyword
	var details=messageBlocks[3];


	timestamp=unixTimestampToJavascriptDate(timestamp/1000);
	//split functions by log level

	//to minimize computation, send a socket message which specifies which groundstation must be updated
	
	if(level=="notice")
	{
		//this is a general message, most probably a state change

		//check to see if this is indeed a state change:
		//we assume the format of this message will be info:pitcrew:state_change:<first_state>-><second_state>
		if(_event=="state_change")
		{
			//update groundstation state
			var stateBlocks=details.split("->");
			var newState=stateBlocks[1];

			GLOBAL.db.collection('stationlist').update({id:groundstation_id}, {$set: {state:newState}}, function()
			{
				msg={update_type:'state', data: newState, id:groundstation_id, timestamp:(timestamp)};
				console.log("MESSAGE: ");
				console.log(msg);
				io.sockets.emit('update_station_data', msg);
			});
		}
		if(_event=="status")
		{
			//telling us the status, i.e. "status=busy"
			var newStatus=details;
			console.log("STATUS: " + newStatus);
			
			GLOBAL.db.collection('stationlist').update({id:groundstation_id}, {$set: {status:newStatus}}, function()
			{
				var msg={update_type:'status', data: newStatus.toUpperCase(), id:groundstation_id, timestamp:unixTimestampToJavascriptDate(timestamp)};
				
				io.sockets.emit('update_station_data', msg);
			});
		}
		if(_event=="number_of_swaps")
		{
			var number_of_swaps=details;

			GLOBAL.db.collection('stationlist').update({id:groundstation_id}, {$set:{number_of_swaps:number_of_swaps}}, function()
			{
				var msg={update_type:'number_of_swaps', data: number_of_swaps, id:groundstation_id, timestamp:unixTimestampToJavascriptDate(timestamp)};
				
				io.sockets.emit('update_station_data', msg);
			});
		}

	}
	else if(level=="alert")
	{
		//update GS state and status
		//the alert level is given only to CRASH messages.  We won't know the reason for the crash (presumably a timeout), only the responsible module.
		var responsible_module=details;
		if(_event=="crash")
		{
			var newStatus="DOWN";
			GLOBAL.db.collection('stationlist').find({id:groundstation_id}).toArray(function(err, item)
			{
				var currentState=item[0].state;
				item[0].state=responsible_module + " " + _event + " @" + currentState;
				GLOBAL.db.collection('stationlist').update({id:groundstation_id}, {$set: {status:newStatus, state:item[0].state}}, function()
				{
					io.sockets.emit('update_station_data', item[0]);
				});
			
				//add this to the errorlist
				var newError={timestamp:timestamp, module:responsible_module, ground_station_id:groundstation_id, state:newState, notes:"Failed after " + currentState, error_message: _event, swaps_before_error:item[0].number_of_swaps};
				GLOBAL.db.collection('errorlist').insert(newError, function()
				{
					io.sockets.emit('add_error', newError);
				});
			});

			
		}
	}
	else if(level=="error")
	{
		//update GS state and status
		var responsible_module=details;
		if(_event=="timeout")
		{
			var newStatus="DOWN";
			GLOBAL.db.collection('stationlist').find({id:groundstation_id}).toArray(function(err, item)
			{
				var currentState=item[0].state;
				var newState=responsible_module + " " + _event + " @" + currentState;
				GLOBAL.db.collection('stationlist').update({id:groundstation_id}, {$set: {status:newStatus, state:newState, lifetime_errors:(item[0].lifetime_errors+1)}});

				//add this to the errorlist
				GLOBAL.db.collection('errorlist').insert({timestamp:timestamp, module:responsible_module, ground_station_id:groundstation_id, state:newState, notes:"Failed after " + currentState, error_message: _event, swaps_before_error:number_of_swaps});
			});

		}

	}
	else
	{

	}
}

	
        



















module.exports=server_tools;